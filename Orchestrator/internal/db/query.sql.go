// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearTakenForAgent = `-- name: ClearTakenForAgent :exec
DELETE FROM taken_expressions
WHERE agent = $1
`

func (q *Queries) ClearTakenForAgent(ctx context.Context, agent string) error {
	_, err := q.db.Exec(ctx, clearTakenForAgent, agent)
	return err
}

const deleteTaken = `-- name: DeleteTaken :exec
DELETE FROM taken_expressions
WHERE expression_id = $1
`

func (q *Queries) DeleteTaken(ctx context.Context, expressionID int64) error {
	_, err := q.db.Exec(ctx, deleteTaken, expressionID)
	return err
}

const getAgentExpressions = `-- name: GetAgentExpressions :many
SELECT expression_id, agent, calculator
FROM taken_expressions
WHERE agent = $1
`

func (q *Queries) GetAgentExpressions(ctx context.Context, agent string) ([]TakenExpression, error) {
	rows, err := q.db.Query(ctx, getAgentExpressions, agent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TakenExpression
	for rows.Next() {
		var i TakenExpression
		if err := rows.Scan(&i.ExpressionID, &i.Agent, &i.Calculator); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAgents = `-- name: GetAgents :many
SELECT agent from taken_expressions
`

func (q *Queries) GetAgents(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAgents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var agent string
		if err := rows.Scan(&agent); err != nil {
			return nil, err
		}
		items = append(items, agent)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpression = `-- name: GetExpression :one
SELECT id, expression, status, result, created_at, calculated_at FROM expressions
WHERE id = $1
`

func (q *Queries) GetExpression(ctx context.Context, id int64) (Expression, error) {
	row := q.db.QueryRow(ctx, getExpression, id)
	var i Expression
	err := row.Scan(
		&i.ID,
		&i.Expression,
		&i.Status,
		&i.Result,
		&i.CreatedAt,
		&i.CalculatedAt,
	)
	return i, err
}

const getExpressions = `-- name: GetExpressions :many
SELECT id, expression, status, result, created_at, calculated_at from expressions
`

func (q *Queries) GetExpressions(ctx context.Context) ([]Expression, error) {
	rows, err := q.db.Query(ctx, getExpressions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expression
	for rows.Next() {
		var i Expression
		if err := rows.Scan(
			&i.ID,
			&i.Expression,
			&i.Status,
			&i.Result,
			&i.CreatedAt,
			&i.CalculatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOperations = `-- name: GetOperations :many
SELECT id, operation, cost FROM operations
`

func (q *Queries) GetOperations(ctx context.Context) ([]Operation, error) {
	rows, err := q.db.Query(ctx, getOperations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Operation
	for rows.Next() {
		var i Operation
		if err := rows.Scan(&i.ID, &i.Operation, &i.Cost); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubexpressions = `-- name: GetSubexpressions :many
SELECT se.id, se.expression_id, se.operand1, se.operand2, se.operation, se.cost, se.exec_order, se.status, se.result
FROM sub_expressions se
INNER JOIN expressions e ON se.expression_id = e.id
WHERE e.id = $1
`

func (q *Queries) GetSubexpressions(ctx context.Context, id int64) ([]SubExpression, error) {
	rows, err := q.db.Query(ctx, getSubexpressions, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubExpression
	for rows.Next() {
		var i SubExpression
		if err := rows.Scan(
			&i.ID,
			&i.ExpressionID,
			&i.Operand1,
			&i.Operand2,
			&i.Operation,
			&i.Cost,
			&i.ExecOrder,
			&i.Status,
			&i.Result,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTask = `-- name: GetTask :one
SELECT id, expression, status, result, created_at, calculated_at FROM expressions
WHERE status = 'wait' LIMIT 1
`

func (q *Queries) GetTask(ctx context.Context) (Expression, error) {
	row := q.db.QueryRow(ctx, getTask)
	var i Expression
	err := row.Scan(
		&i.ID,
		&i.Expression,
		&i.Status,
		&i.Result,
		&i.CreatedAt,
		&i.CalculatedAt,
	)
	return i, err
}

const inputResultExpression = `-- name: InputResultExpression :exec
UPDATE expressions
SET result = $2, status = 'done' , calculated_at = now()
WHERE id = $1
`

type InputResultExpressionParams struct {
	ID     int64   `json:"id"`
	Result float64 `json:"result"`
}

func (q *Queries) InputResultExpression(ctx context.Context, arg InputResultExpressionParams) error {
	_, err := q.db.Exec(ctx, inputResultExpression, arg.ID, arg.Result)
	return err
}

const inputResultSubExpression = `-- name: InputResultSubExpression :exec
UPDATE sub_expressions
SET result = $2 , status = 'done'
WHERE id = $1
`

type InputResultSubExpressionParams struct {
	ID     int64   `json:"id"`
	Result float64 `json:"result"`
}

func (q *Queries) InputResultSubExpression(ctx context.Context, arg InputResultSubExpressionParams) error {
	_, err := q.db.Exec(ctx, inputResultSubExpression, arg.ID, arg.Result)
	return err
}

const insertExpression = `-- name: InsertExpression :one
INSERT INTO expressions (expression, status, created_at)
VALUES ($1, $2, $3)
RETURNING id
`

type InsertExpressionParams struct {
	Expression string             `json:"expression"`
	Status     ExpressionStatus   `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) InsertExpression(ctx context.Context, arg InsertExpressionParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertExpression, arg.Expression, arg.Status, arg.CreatedAt)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertSubExpression = `-- name: InsertSubExpression :exec
INSERT INTO sub_expressions(expression_id,operand1,operation,operand2,cost,exec_order)
VALUES ($1,$2,$3,$4,$5,$6)
`

type InsertSubExpressionParams struct {
	ExpressionID int64           `json:"expression_id"`
	Operand1     string          `json:"operand1"`
	Operation    OperationSymbol `json:"operation"`
	Operand2     string          `json:"operand2"`
	Cost         int32           `json:"cost"`
	ExecOrder    int32           `json:"exec_order"`
}

func (q *Queries) InsertSubExpression(ctx context.Context, arg InsertSubExpressionParams) error {
	_, err := q.db.Exec(ctx, insertSubExpression,
		arg.ExpressionID,
		arg.Operand1,
		arg.Operation,
		arg.Operand2,
		arg.Cost,
		arg.ExecOrder,
	)
	return err
}

const insertTaken = `-- name: InsertTaken :exec
INSERT INTO taken_expressions (expression_id,agent,calculator)
VALUES ($1,$2,$3)
`

type InsertTakenParams struct {
	ExpressionID int64  `json:"expression_id"`
	Agent        string `json:"agent"`
	Calculator   int32  `json:"calculator"`
}

func (q *Queries) InsertTaken(ctx context.Context, arg InsertTakenParams) error {
	_, err := q.db.Exec(ctx, insertTaken, arg.ExpressionID, arg.Agent, arg.Calculator)
	return err
}

const monitor = `-- name: Monitor :many
SELECT t.agent,t.calculator,e.expression,e.status 
FROM taken_expressions t 
RIGHT JOIN expressions e ON expressions.id = t.expression_id
`

type MonitorRow struct {
	Agent      pgtype.Text      `json:"agent"`
	Calculator pgtype.Int4      `json:"calculator"`
	Expression string           `json:"expression"`
	Status     ExpressionStatus `json:"status"`
}

func (q *Queries) Monitor(ctx context.Context) ([]MonitorRow, error) {
	rows, err := q.db.Query(ctx, monitor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MonitorRow
	for rows.Next() {
		var i MonitorRow
		if err := rows.Scan(
			&i.Agent,
			&i.Calculator,
			&i.Expression,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExpressionStatus = `-- name: UpdateExpressionStatus :exec
UPDATE expressions SET status = $2 WHERE id = $1
`

type UpdateExpressionStatusParams struct {
	ID     int64            `json:"id"`
	Status ExpressionStatus `json:"status"`
}

func (q *Queries) UpdateExpressionStatus(ctx context.Context, arg UpdateExpressionStatusParams) error {
	_, err := q.db.Exec(ctx, updateExpressionStatus, arg.ID, arg.Status)
	return err
}

const updateOperation = `-- name: UpdateOperation :exec
UPDATE operations 
SET cost = $2
WHERE operation = $1
`

type UpdateOperationParams struct {
	Operation OperationSymbol `json:"operation"`
	Cost      int32           `json:"cost"`
}

func (q *Queries) UpdateOperation(ctx context.Context, arg UpdateOperationParams) error {
	_, err := q.db.Exec(ctx, updateOperation, arg.Operation, arg.Cost)
	return err
}
