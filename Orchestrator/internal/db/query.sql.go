// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearTakenForAgent = `-- name: ClearTakenForAgent :exec
DELETE FROM taken_expressions
WHERE agent = $1
`

func (q *Queries) ClearTakenForAgent(ctx context.Context, agent string) error {
	_, err := q.db.Exec(ctx, clearTakenForAgent, agent)
	return err
}

const deleteTaken = `-- name: DeleteTaken :exec
DELETE FROM taken_expressions
WHERE expression_id = $1
`

func (q *Queries) DeleteTaken(ctx context.Context, expressionID int64) error {
	_, err := q.db.Exec(ctx, deleteTaken, expressionID)
	return err
}

const getAgentExpressions = `-- name: GetAgentExpressions :many
SELECT expression_id, agent, calculator
FROM taken_expressions
WHERE agent = $1
`

func (q *Queries) GetAgentExpressions(ctx context.Context, agent string) ([]TakenExpression, error) {
	rows, err := q.db.Query(ctx, getAgentExpressions, agent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TakenExpression
	for rows.Next() {
		var i TakenExpression
		if err := rows.Scan(&i.ExpressionID, &i.Agent, &i.Calculator); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpression = `-- name: GetExpression :one
SELECT id, expression, status, result, created_at, calculated_at FROM expressions
WHERE id = $1
`

func (q *Queries) GetExpression(ctx context.Context, id int64) (Expression, error) {
	row := q.db.QueryRow(ctx, getExpression, id)
	var i Expression
	err := row.Scan(
		&i.ID,
		&i.Expression,
		&i.Status,
		&i.Result,
		&i.CreatedAt,
		&i.CalculatedAt,
	)
	return i, err
}

const getExpressions = `-- name: GetExpressions :many
SELECT id, expression, status, result, created_at, calculated_at from expressions
`

func (q *Queries) GetExpressions(ctx context.Context) ([]Expression, error) {
	rows, err := q.db.Query(ctx, getExpressions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expression
	for rows.Next() {
		var i Expression
		if err := rows.Scan(
			&i.ID,
			&i.Expression,
			&i.Status,
			&i.Result,
			&i.CreatedAt,
			&i.CalculatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOperations = `-- name: GetOperations :many
SELECT id, operation, cost from operations
`

func (q *Queries) GetOperations(ctx context.Context) ([]Operation, error) {
	rows, err := q.db.Query(ctx, getOperations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Operation
	for rows.Next() {
		var i Operation
		if err := rows.Scan(&i.ID, &i.Operation, &i.Cost); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubexpressions = `-- name: GetSubexpressions :many
SELECT se.id, se.expression_id, se.expression, se.exec_order, se.result
FROM sub_expressions se
INNER JOIN expressions e ON se.expression_id = e.id
WHERE e.id = $1
`

func (q *Queries) GetSubexpressions(ctx context.Context, id int64) ([]SubExpression, error) {
	rows, err := q.db.Query(ctx, getSubexpressions, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubExpression
	for rows.Next() {
		var i SubExpression
		if err := rows.Scan(
			&i.ID,
			&i.ExpressionID,
			&i.Expression,
			&i.ExecOrder,
			&i.Result,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const inputResultExpression = `-- name: InputResultExpression :exec
UPDATE expressions
SET result = $2, status = 'done'
WHERE id = $1
`

type InputResultExpressionParams struct {
	ID     int64         `json:"id"`
	Result pgtype.Float8 `json:"result"`
}

func (q *Queries) InputResultExpression(ctx context.Context, arg InputResultExpressionParams) error {
	_, err := q.db.Exec(ctx, inputResultExpression, arg.ID, arg.Result)
	return err
}

const inputResultSubExpression = `-- name: InputResultSubExpression :exec
UPDATE sub_expressions
SET result = $2
WHERE id = $1
`

type InputResultSubExpressionParams struct {
	ID     int64         `json:"id"`
	Result pgtype.Float8 `json:"result"`
}

func (q *Queries) InputResultSubExpression(ctx context.Context, arg InputResultSubExpressionParams) error {
	_, err := q.db.Exec(ctx, inputResultSubExpression, arg.ID, arg.Result)
	return err
}

const insertExpression = `-- name: InsertExpression :one
INSERT INTO expressions (expression, status, created_at)
VALUES ($1, $2, $3)
RETURNING id
`

type InsertExpressionParams struct {
	Expression string             `json:"expression"`
	Status     ExpressionStatus   `json:"status"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) InsertExpression(ctx context.Context, arg InsertExpressionParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertExpression, arg.Expression, arg.Status, arg.CreatedAt)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertSubExpression = `-- name: InsertSubExpression :exec
INSERT INTO sub_expressions(expression_id,expression)
VALUES ($1,$2)
`

type InsertSubExpressionParams struct {
	ExpressionID int64  `json:"expression_id"`
	Expression   string `json:"expression"`
}

func (q *Queries) InsertSubExpression(ctx context.Context, arg InsertSubExpressionParams) error {
	_, err := q.db.Exec(ctx, insertSubExpression, arg.ExpressionID, arg.Expression)
	return err
}

const insertTaken = `-- name: InsertTaken :exec
INSERT INTO taken_expressions (expression_id,agent,calculator)
VALUES ($1,$2,$3)
`

type InsertTakenParams struct {
	ExpressionID int64  `json:"expression_id"`
	Agent        string `json:"agent"`
	Calculator   int32  `json:"calculator"`
}

func (q *Queries) InsertTaken(ctx context.Context, arg InsertTakenParams) error {
	_, err := q.db.Exec(ctx, insertTaken, arg.ExpressionID, arg.Agent, arg.Calculator)
	return err
}

const updateOperation = `-- name: UpdateOperation :exec
UPDATE operations 
SET cost = $2
WHERE operation = $1
`

type UpdateOperationParams struct {
	Operation OperationSymbol `json:"operation"`
	Cost      int32           `json:"cost"`
}

func (q *Queries) UpdateOperation(ctx context.Context, arg UpdateOperationParams) error {
	_, err := q.db.Exec(ctx, updateOperation, arg.Operation, arg.Cost)
	return err
}
