// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type ExpressionStatus string

const (
	ExpressionStatusWait       ExpressionStatus = "wait"
	ExpressionStatusProcessing ExpressionStatus = "processing"
	ExpressionStatusInvalid    ExpressionStatus = "invalid"
	ExpressionStatusDone       ExpressionStatus = "done"
)

func (e *ExpressionStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ExpressionStatus(s)
	case string:
		*e = ExpressionStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ExpressionStatus: %T", src)
	}
	return nil
}

type NullExpressionStatus struct {
	ExpressionStatus ExpressionStatus `json:"expression_status"`
	Valid            bool             `json:"valid"` // Valid is true if ExpressionStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullExpressionStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ExpressionStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ExpressionStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullExpressionStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ExpressionStatus), nil
}

type OperationSymbol string

const (
	OperationSymbolValue0 OperationSymbol = "+"
	OperationSymbolValue1       OperationSymbol = "-"
	OperationSymbolValue2 OperationSymbol = "*"
	OperationSymbolValue3 OperationSymbol = "/"
)

func (e *OperationSymbol) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OperationSymbol(s)
	case string:
		*e = OperationSymbol(s)
	default:
		return fmt.Errorf("unsupported scan type for OperationSymbol: %T", src)
	}
	return nil
}

type NullOperationSymbol struct {
	OperationSymbol OperationSymbol `json:"operation_symbol"`
	Valid           bool            `json:"valid"` // Valid is true if OperationSymbol is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOperationSymbol) Scan(value interface{}) error {
	if value == nil {
		ns.OperationSymbol, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OperationSymbol.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOperationSymbol) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OperationSymbol), nil
}

type Expression struct {
	ID           int64              `json:"id"`
	Expression   string             `json:"expression"`
	Status       ExpressionStatus   `json:"status"`
	Result       float64            `json:"result"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	CalculatedAt pgtype.Timestamptz `json:"calculated_at"`
}

type Operation struct {
	ID        int64           `json:"id"`
	Operation OperationSymbol `json:"operation"`
	Cost      int32           `json:"cost"`
}

type SubExpression struct {
	ID           int64            `json:"id"`
	ExpressionID int64            `json:"expression_id"`
	Operand1     string           `json:"operand1"`
	Operand2     string           `json:"operand2"`
	Operation    OperationSymbol  `json:"operation"`
	Cost         int32            `json:"cost"`
	ExecOrder    int32            `json:"exec_order"`
	Status       ExpressionStatus `json:"status"`
	Result       float64          `json:"result"`
}

type TakenExpression struct {
	ExpressionID int64  `json:"expression_id"`
	Agent        string `json:"agent"`
	Calculator   int32  `json:"calculator"`
}
